#include "includes.h"
#include "sdk.h"
#include "kiero/minhook/include/MinHook.h"
#include <vector>
#include <Windows.h>
#include <iostream>
#include <string>
#include "obfuscation.h"
//Full Credits
// "batman" (Was credited in MastoidHook)
// Mio (original miohook)
// Mastoid (MastoidHook)
// SilverXK (Updated Hook) 
// JewishTricks (Help with Cheats)
// Chocolatte (Finding and testing DX11 Hook)
// Kiero (For the DX11 Hook)

// Removed Features for public
// DLC Enabler/Disabler
// Freeze Host
// DOS Host
// File Transfer

__forceinline void SMKOZGZ070P8()
{
	//junkcode
	int D2H4DJESOA7CJ = 251367161;
	if (D2H4DJESOA7CJ > 251367154)
		D2H4DJESOA7CJ = 251367128;
	else if (D2H4DJESOA7CJ <= 251367168)
		D2H4DJESOA7CJ++;
	else
		D2H4DJESOA7CJ = (251367179 / 251367166);
	bool DG6SK98740CKP = true;
	if (!DG6SK98740CKP)
		DG6SK98740CKP = true;
	else if (DG6SK98740CKP = true)
		DG6SK98740CKP = true;
	else
		DG6SK98740CKP = true;
	bool D16R2A4ZA5WKR = false;
	if (!D16R2A4ZA5WKR)
		D16R2A4ZA5WKR = true;
	else if (D16R2A4ZA5WKR = true)
		D16R2A4ZA5WKR = true;
	else
		D16R2A4ZA5WKR = true;
	int DDSES5C3IXB0B = 251367187;
	if (DDSES5C3IXB0B > 251367118)
		DDSES5C3IXB0B = 251367108;
	else if (DDSES5C3IXB0B <= 251367123)
		DDSES5C3IXB0B++;
	else
		DDSES5C3IXB0B = (251367110 / 251367107);
	int DJD55RON4Y04R = 251367109;
	if (DJD55RON4Y04R > 251367194)
		DJD55RON4Y04R = 251367155;
	else if (DJD55RON4Y04R <= 251367133)
		DJD55RON4Y04R++;
	else
		DJD55RON4Y04R = (251367117 / 251367112);
	bool D9L8D16I270S3 = true;
	if (!D9L8D16I270S3)
		D9L8D16I270S3 = false;
	else if (D9L8D16I270S3 = true)
		D9L8D16I270S3 = true;
	else
		D9L8D16I270S3 = true;
	bool DBA11L04RS4HA = false;
	if (!DBA11L04RS4HA)
		DBA11L04RS4HA = false;
	else if (DBA11L04RS4HA = true)
		DBA11L04RS4HA = false;
	else
		DBA11L04RS4HA = false;
	bool D8YI6PBH70M7H = true;
	if (!D8YI6PBH70M7H)
		D8YI6PBH70M7H = false;
	else if (D8YI6PBH70M7H = true)
		D8YI6PBH70M7H = true;
	else
		D8YI6PBH70M7H = true;
	int D93IEQGCBJP4L = 251367116;
	if (D93IEQGCBJP4L > 251367193)
		D93IEQGCBJP4L = 251367102;
	else if (D93IEQGCBJP4L <= 251367125)
		D93IEQGCBJP4L++;
	else
		D93IEQGCBJP4L = (251367157 / 251367177);
	bool DF5BGNPC2HYZY = true;
	if (!DF5BGNPC2HYZY)
		DF5BGNPC2HYZY = true;
	else if (DF5BGNPC2HYZY = false)
		DF5BGNPC2HYZY = true;
	else
		DF5BGNPC2HYZY = true;
	bool D2WM5I40F5N7G = true;
	if (!D2WM5I40F5N7G)
		D2WM5I40F5N7G = true;
	else if (D2WM5I40F5N7G = true)
		D2WM5I40F5N7G = false;
	else
		D2WM5I40F5N7G = true;
	int DHHY670IZGMSZ = 251367112;
	if (DHHY670IZGMSZ > 251367160)
		DHHY670IZGMSZ = 251367166;
	else if (DHHY670IZGMSZ <= 251367162)
		DHHY670IZGMSZ++;
	else
		DHHY670IZGMSZ = (251367195 / 251367179);
	int DOSOO6KDSJ525 = 251367155;
	if (DOSOO6KDSJ525 > 251367143)
		DOSOO6KDSJ525 = 251367140;
	else if (DOSOO6KDSJ525 <= 251367191)
		DOSOO6KDSJ525++;
	else
		DOSOO6KDSJ525 = (251367160 / 251367183);
	bool D3GPX093G35EQ = true;
	if (!D3GPX093G35EQ)
		D3GPX093G35EQ = true;
	else if (D3GPX093G35EQ = true)
		D3GPX093G35EQ = false;
	else
		D3GPX093G35EQ = false;
	bool DGELE95I8DP95 = false;
	if (!DGELE95I8DP95)
		DGELE95I8DP95 = false;
	else if (DGELE95I8DP95 = true)
		DGELE95I8DP95 = false;
	else
		DGELE95I8DP95 = true;
	int DGCEZXPN9FKIS = 251367129;
	if (DGCEZXPN9FKIS > 251367167)
		DGCEZXPN9FKIS = 251367193;
	else if (DGCEZXPN9FKIS <= 251367155)
		DGCEZXPN9FKIS++;
	else
		DGCEZXPN9FKIS = (251367119 / 251367167);
	int D09KC604Z9GOC = 251367136;
	if (D09KC604Z9GOC > 251367112)
		D09KC604Z9GOC = 251367143;
	else if (D09KC604Z9GOC <= 251367131)
		D09KC604Z9GOC++;
	else
		D09KC604Z9GOC = (251367177 / 251367135);
	bool D7MKKCJ7OE5CW = true;
	if (!D7MKKCJ7OE5CW)
		D7MKKCJ7OE5CW = false;
	else if (D7MKKCJ7OE5CW = true)
		D7MKKCJ7OE5CW = false;
	else
		D7MKKCJ7OE5CW = true;
	bool DE78OSX4PF3X6 = false;
	if (!DE78OSX4PF3X6)
		DE78OSX4PF3X6 = true;
	else if (DE78OSX4PF3X6 = false)
		DE78OSX4PF3X6 = true;
	else
		DE78OSX4PF3X6 = false;
	int DG2H1W3M9CMGE = 251367122;
	if (DG2H1W3M9CMGE > 251367129)
		DG2H1W3M9CMGE = 251367171;
	else if (DG2H1W3M9CMGE <= 251367176)
		DG2H1W3M9CMGE++;
	else
		DG2H1W3M9CMGE = (251367125 / 251367192);
	bool DALD5LWQZ09AE = false;
	if (!DALD5LWQZ09AE)
		DALD5LWQZ09AE = true;
	else if (DALD5LWQZ09AE = false)
		DALD5LWQZ09AE = true;
	else
		DALD5LWQZ09AE = false;
	bool DC2JQWRCERB0P = true;
	if (!DC2JQWRCERB0P)
		DC2JQWRCERB0P = true;
	else if (DC2JQWRCERB0P = false)
		DC2JQWRCERB0P = true;
	else
		DC2JQWRCERB0P = false;
	int DRXHCRLWNISB8 = 251367190;
	if (DRXHCRLWNISB8 > 251367107)
		DRXHCRLWNISB8 = 251367188;
	else if (DRXHCRLWNISB8 <= 251367160)
		DRXHCRLWNISB8++;
	else
		DRXHCRLWNISB8 = (251367134 / 251367163);
	int DNQ0H7PF1G1FA = 251367170;
	if (DNQ0H7PF1G1FA > 251367126)
		DNQ0H7PF1G1FA = 251367154;
	else if (DNQ0H7PF1G1FA <= 251367146)
		DNQ0H7PF1G1FA++;
	else
		DNQ0H7PF1G1FA = (251367126 / 251367101);
	bool D55H41HJE700J = false;
	if (!D55H41HJE700J)
		D55H41HJE700J = true;
	else if (D55H41HJE700J = true)
		D55H41HJE700J = true;
	else
		D55H41HJE700J = true;
	int D4ZKM96EG7EN0 = 251367178;
	if (D4ZKM96EG7EN0 > 251367160)
		D4ZKM96EG7EN0 = 251367129;
	else if (D4ZKM96EG7EN0 <= 251367175)
		D4ZKM96EG7EN0++;
	else
		D4ZKM96EG7EN0 = (251367195 / 251367186);
	bool D6CZ693M604QP = true;
	if (!D6CZ693M604QP)
		D6CZ693M604QP = true;
	else if (D6CZ693M604QP = false)
		D6CZ693M604QP = true;
	else
		D6CZ693M604QP = true;
	bool DIG4SR0I5E3FN = true;
	if (!DIG4SR0I5E3FN)
		DIG4SR0I5E3FN = false;
	else if (DIG4SR0I5E3FN = true)
		DIG4SR0I5E3FN = false;
	else
		DIG4SR0I5E3FN = true;
	int DAR13LN9XH2CO = 251367111;
	if (DAR13LN9XH2CO > 251367194)
		DAR13LN9XH2CO = 251367131;
	else if (DAR13LN9XH2CO <= 251367176)
		DAR13LN9XH2CO++;
	else
		DAR13LN9XH2CO = (251367131 / 251367178);
	int DFHM2833G8RWY = 251367111;
	if (DFHM2833G8RWY > 251367147)
		DFHM2833G8RWY = 251367125;
	else if (DFHM2833G8RWY <= 251367124)
		DFHM2833G8RWY++;
	else
		DFHM2833G8RWY = (251367104 / 251367197);
	int DJ5M0EMKW0GXP = 251367171;
	if (DJ5M0EMKW0GXP > 251367115)
		DJ5M0EMKW0GXP = 251367153;
	else if (DJ5M0EMKW0GXP <= 251367193)
		DJ5M0EMKW0GXP++;
	else
		DJ5M0EMKW0GXP = (251367157 / 251367153);
	bool DJMPPX18D4KX6 = true;
	if (!DJMPPX18D4KX6)
		DJMPPX18D4KX6 = true;
	else if (DJMPPX18D4KX6 = true)
		DJMPPX18D4KX6 = true;
	else
		DJMPPX18D4KX6 = false;
}




typedef bool(__fastcall* CSessionPost)(void* pThis, CCommand* pCommand, bool ForceSend);
CSessionPost CSessionPostHook;
CSessionPost CSessionPostTramp;

typedef CAddPlayerCommand* (__fastcall* GetCAddPlayerCommand)(void* pThis, CString* User, CString* Name, DWORD* unknown, int nMachineId, bool bHotjoin, __int64 a7);
GetCAddPlayerCommand CAddPlayerCommandHook;
GetCAddPlayerCommand CAddPlayerCommandTramp;

typedef CStartGameCommand* (__fastcall* GetCStartGameCommand)(void* pThis);
GetCStartGameCommand CStartGameCommandFunc;

typedef CRemovePlayerCommand* (*GetCRemovePlayerCommand)(void* pThis, int nMachineId, int eReason, long long a4);
GetCRemovePlayerCommand CRemovePlayerCommandHook;
GetCRemovePlayerCommand CRemovePlayerCommandTramp;

typedef __int64(__fastcall* CGameStateSetPlayer)(void* pThis, int* Tag);
CGameStateSetPlayer CGameStateSetPlayerHook;
CGameStateSetPlayer CGameStateSetPlayerTramp;


typedef CNameChange* (__fastcall* GetCNameChangeCommand)(void* pThis, CString* name);
GetCNameChangeCommand CNameChangeFunc;
GetCNameChangeCommand CNameChangeTramp;

typedef CChatMessage* (__fastcall* GetCChatMessage)(void* pThis, __int64 a2, __int64 Message);
GetCChatMessage CChatMessageHook;
GetCChatMessage CChatMessageTramp;

typedef CSetDLCsCommand* (__fastcall* GetCSetDLCsCommand)(void* pThis, unsigned int nDLCs);
GetCSetDLCsCommand CSetDLCsCommandFunc;
GetCSetDLCsCommand CSetDLCsTramp;

typedef CCreateEquipmentVariant* (__fastcall* GetCCreateEquipmentVariant)(void* pThis, __int64 a2, __int64 a3, int a4, __int64* a5, _int64* a6, char a7);
GetCCreateEquipmentVariant CCreateEquipmentFunc;
GetCCreateEquipmentVariant CCreateEquipmentTramp;

typedef CPauseGameCommand* (__fastcall* GetCPauseGameCommand)(void* pthis, __int64 a2, char a3);
GetCPauseGameCommand CPauseGameFunc;

typedef CAiEnableCommand* (__fastcall* GetEnableAI)(void* pThis, int* tag, int toggled);
GetEnableAI AIEnableFunc;

typedef CChatLeaveFake* (_fastcall* GetCChatLeaveFake)(void* pThis, int eReason);
GetCChatLeaveFake ChatLeaveFunc;

typedef LPVOID(__fastcall* GetCCommand)(__int64 a1);
GetCCommand GetCCommandFunc;



// For other langauges
std::string lCheatTitle = "";
std::string lSteamName = "";
std::string lJoinAsGhost = "";
std::string lMLH = "";
std::string lXP = "";
std::string lCrasher = "";
std::string lCrasherText = "";
std::string lFunctionCallText = "";
std::string lFakeKick = "";
std::string lStartGame = "";
std::string lDisableDLCs = "";
std::string lMemAddresses = "";
std::string lFOW = "";
std::string lAllowTraits = "";
std::string lDBG = "";
std::string lTagSwitchText = "";
std::string lTagSwitch = "";
std::string lReset = "";
std::string lCredits = "";


int FakeM = 1;
bool FakeSpammer = false;


bool Debug = false;
bool XP0 = false;
//ChatMessage
__int64 pCMessage = NULL;

//SessionPost
void* pCSession = nullptr;

//AddPlayerCommand
void* pCAddPlayer = nullptr;
DWORD* dT;
int dM;
__int64 dP;
CString* dN;
CString* dNN;
bool bMaxNameSize = false;
bool bJoinAsGhost = false;
int iMyMachineID;
int iMachineIDFake = 50;
__int64 iParadoxSocialID = 0;
CString* empty = new CString;
bool lala = false;

//RemovePlayerCommand
void* pCRemovePlayer = nullptr;
ERemovalReason dReason;
int RMID;
int dUnknown;

//GameSetState
void* pCGameState = nullptr;

//Langauge
bool lEnglish = true;
bool lRussian = false;
bool HasNotChanged = false;

//ImGui
bool bMenuOpen = true;
bool bCE = false;
bool bCrasher = false;
bool bXP = false;
bool CheatLobbyEnabled = false;
bool bInfinitePaused = false;
int KeyArray[] = { 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39 };
char TagBuffer[8];
char MessageBuffer[256];

//Hook
extern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
Present oPresent;
HWND window = NULL;
WNDPROC oWndProc;
ID3D11Device* pDevice = NULL;
ID3D11DeviceContext* pContext = NULL;
ID3D11RenderTargetView* mainRenderTargetView;
uintptr_t GameBase = (uintptr_t)GetModuleHandleA("hoi4.exe");

//Misc (Unused)
bool bFakePname = false;
bool bEnabletdebug = false;


void printm(std::string str)
{
	FILE* fDummy;
	freopen_s(&fDummy, "CONOUT$", "w", stdout);

	std::cout << "[SilverHook] " << str << std::endl;
}

//Cheats
void PatchMemory(uintptr_t address, unsigned char* patch, DWORD size)
{
	DWORD oldProtect;
	VirtualProtect((LPVOID)address, size, PAGE_EXECUTE_READWRITE, &oldProtect);
	memcpy((LPVOID)address, patch, size);
	VirtualProtect((LPVOID)address, size, oldProtect, &oldProtect);
}


void MultiplayerLobbyHack()
{

	uintptr_t address = GameBase + 0x185CD2F;

	unsigned char patch[] = { 0x74, 0x0F, 0x83, 0xFA, 0x01, 0x00 }; 

	void* MLHmem = VirtualAlloc(nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (MLHmem != nullptr)
	{
		DWORD relativeOffset = (GameBase + 0x185CD40) - (address + sizeof(patch));
		memcpy(MLHmem, patch, sizeof(patch));
		*(BYTE*)((uintptr_t)MLHmem) = 0x0F;
		*(BYTE*)((uintptr_t)MLHmem + 1) = 0x83;
		*(DWORD*)((uintptr_t)MLHmem + 2) = relativeOffset;
		PatchMemory(address, (unsigned char*)MLHmem, sizeof(patch));
		VirtualFree(MLHmem, 0, MEM_RELEASE);
	}

}



void UpgradeLevelLimiter() {

	uintptr_t addr = GameBase + 0x1B1C1E0;

	unsigned char newValue = 0x99;

	unsigned char newCode[] = {
		0x41, 0xC7, 0x85, 0x0C, 0x01, 0x00, 0x00, newValue, 0x00,0x00, 0x00,  // mov [r13+0000010C], newValue
		  
		0x90, 0x90, 0x90, 0x90   // nop 2 (two NOP instructions)
	};

	
	PatchMemory(addr, newCode, sizeof(newCode));
	//XPCostMultiplayer();

}

void XPCostMultiplier() {

	uintptr_t addr = GameBase + 0x1B1C274;

	
	void* newMem = VirtualAlloc(NULL, 1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	
	unsigned char newCode[] = {
		0xB9, 0xF4, 0x01, 0x00, 0x00,         // mov ecx, 500 (500 in hex is 0x01F4, little-endian)
		0x89, 0x8F, 0xD0, 0x09, 0x00, 0x00,  // mov [rdi+000009D0], ecx
		0xE9, 0x6D, 0xC2, 0x7E, 0xFE          // jmp return 
	};


	PatchMemory((uintptr_t)newMem, newCode, sizeof(newCode));

	unsigned char jmpToNewMem[] = {
		0xE9, 0x87, 0x3D, 0x81, 0x01,  // jmp newMem
		0x90, 0x90, 0x90               // NOP x3
	};

	PatchMemory(addr, jmpToNewMem, sizeof(jmpToNewMem));
}



/*	uintptr_t addr = GameBase + 0x1B1C274;
	unsigned char bytesToPatch[] = { 0x8B, 0x08, 0x89, 0x8F, 0xD0, 0x09, 0x00, 0x00 };

	unsigned char newCode[] = { 
		0xB9, 0xF4, 0x01, 0x00, 0x00,         
		0x89, 0x8F, 0xD0, 0x09, 0x00, 0x00, 
		/*0x90, 0x90, 0x90,
		0x48, 0x83, 0xC4, 0x30,
		0x41, 0x5F*/

	//};

	//PatchMemory(addr, newCode, sizeof(newCode)); 
	




template <typename T>
T ReadMemory(uintptr_t address)
{
	return *reinterpret_cast<T*>(address);
}

uintptr_t OffsetCalculator(uintptr_t baseAddress, const std::vector<uintptr_t>& offsets)
{
	uintptr_t address = baseAddress;
	for (uintptr_t offset : offsets)
	{
		address = ReadMemory<uintptr_t>(address);
		address += offset;
	}
	return address;
}




void FreezeHost() {

}


/*void printm(std::string str)
{
	FILE* fDummy;
	freopen_s(&fDummy, "CONOUT$", "w", stdout);

	std::cout << "[SilverHook] " << str << std::endl;
}*/


void ChangeIntAddressValue(uintptr_t bAddr, uintptr_t bOff, int Tag)
{

	uintptr_t baseAddress = bAddr; 
	
	std::vector<uintptr_t> offsets = { bOff };
	
	uintptr_t finalAddress = OffsetCalculator(GameBase + baseAddress, offsets);

	DWORD* pValue = reinterpret_cast<DWORD*>(finalAddress);
	DWORD oldProtect;

	(VirtualProtect(pValue, sizeof(DWORD), PAGE_EXECUTE_READWRITE, &oldProtect));

	*pValue = Tag;

	VirtualProtect(pValue, sizeof(DWORD), oldProtect, &oldProtect);

}

void ChangeByteAddressValue(uintptr_t addr)
{
	uintptr_t address = GameBase + addr; 
	BYTE* pValue = (BYTE*)address;
	DWORD oldProtect;


	VirtualProtect(pValue, sizeof(BYTE), PAGE_EXECUTE_READWRITE, &oldProtect);
	
	if (*pValue == 1)
	{
		*pValue = 0;
	}
	else
	{
		*pValue = 1;
	}
	
	VirtualProtect(pValue, sizeof(BYTE), oldProtect, &oldProtect);
}


//IngameFunctions
void ToggleDLC(int _nDLC) {
	CSetDLCsCommand* SetDLCs = (CSetDLCsCommand*)GetCCommandFunc(48);
	SetDLCs = CSetDLCsCommandFunc(SetDLCs, _nDLC);
	CSessionPostTramp(pCSession, SetDLCs, true);
}

void FakePlayer(int _MachineID) {
	//do dM for fakekick
	//do dM + 1 for addfakeplayer

	DWORD* tt = dT; // unknown
	int tM = _MachineID; //machine ID
	__int64 tP = dP; //paradox social ID
	CString* tN = dN; //Steam Name
	CString* tNN = dNN; // HOI4 Name

	CAddPlayerCommand* FakeKick = (CAddPlayerCommand*)GetCCommandFunc(168);
	FakeKick = CAddPlayerCommandTramp(FakeKick, tN, tNN, tt, tM, false, tP);
	CSessionPostTramp(pCSession, FakeKick, true);
}

void StartGameFunc() {
	CStartGameCommand* StartGame = (CStartGameCommand*)GetCCommandFunc(41);

	StartGame = CStartGameCommandFunc((StartGame));
	CSessionPostTramp(pCSession, StartGame, true);
}

void RemovalReason(ERemovalReason e) {
	//Only host can remove themselves? (possibly machine ID
	CRemovePlayerCommand* RemovePlayer = (CRemovePlayerCommand*)GetCCommandFunc(41);
	RemovePlayer = CRemovePlayerCommandTramp(RemovePlayer, RMID, e, dUnknown);
	CSessionPostTramp(pCSession, RemovePlayer, true);
}





void InitImGui()
{
	ImGui::CreateContext();
	ImGui::StyleColorsDark();
	
	ImGuiIO& io = ImGui::GetIO();
	io.ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;
	io.Fonts->AddFontFromFileTTF("C:/Windows/Fonts/arial.ttf", 18.0f, NULL, io.Fonts->GetGlyphRangesCyrillic()); // For Russian
	ImGui_ImplWin32_Init(window);
	ImGui_ImplDX11_Init(pDevice, pContext);
	
	ImVec4 NormalColor = ImVec4(0.047f, 0.047f, 0.047f, 1.0f);
	ImVec4 HoverColor = ImVec4(0.066f, 0.066f, 0.066f, 1.0f);
	ImVec4 ActiveColor = ImVec4(0.076f, 0.076f, 0.076f, 1.0f);
	ImVec4 BackgroundColor = ImVec4(0.08f, 0.08f, 0.08f, 1.0f);
	ImVec4 PureBlackColor = ImVec4(0.01f, 0.01f, 0.01f, 1.0f);
	ImVec4 WhiteColor = ImVec4(1.0f, 1.0f, 1.0f, 1.0f);

	ImGuiStyle& style = ImGui::GetStyle();
	style.Colors[ImGuiCol_Button] = NormalColor;  // Normal Colors
	style.Colors[ImGuiCol_FrameBg] = NormalColor;
	style.Colors[ImGuiCol_ResizeGrip] = NormalColor;
	style.Colors[ImGuiCol_Separator] = NormalColor;

	style.Colors[ImGuiCol_ButtonHovered] = HoverColor; //Hovered Colors
	style.Colors[ImGuiCol_ResizeGripHovered] = HoverColor;
	style.Colors[ImGuiCol_FrameBgHovered] = HoverColor;
	style.Colors[ImGuiCol_SeparatorHovered] = HoverColor;

	style.Colors[ImGuiCol_ButtonActive] = ActiveColor; // Active Colors
	style.Colors[ImGuiCol_ResizeGripActive] = ActiveColor;
	style.Colors[ImGuiCol_SeparatorActive] = ActiveColor;
	style.Colors[ImGuiCol_FrameBgActive] = ActiveColor;

	style.Colors[ImGuiCol_WindowBg] = BackgroundColor; // Background

	style.Colors[ImGuiCol_TitleBg] = PureBlackColor; // Title
	style.Colors[ImGuiCol_TitleBgCollapsed] = PureBlackColor;
	style.Colors[ImGuiCol_TitleBgActive] = PureBlackColor;

	style.Colors[ImGuiCol_CheckMark] = WhiteColor; // Checkmark
}

LRESULT __stdcall WndProc(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

	if (true && ImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam))
		return true;

	return CallWindowProc(oWndProc, hWnd, uMsg, wParam, lParam);
}

void* __fastcall sizeFinder(size_t Size) {
	size_t i;
	void* result;

	for (i = Size; ; Size = i) {
		result = malloc(Size);
		if (result) {
			break;
		}
		if (!_callnewh(i)) {
			if (i != -1i64) {
				break;
			}
			break;
		}
	}
	return result;
}


bool init = false;
HRESULT __stdcall hkPresent(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)
{
	if (!init)
	{
		if (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)& pDevice)))
		{
			pDevice->GetImmediateContext(&pContext);
			DXGI_SWAP_CHAIN_DESC sd;
			pSwapChain->GetDesc(&sd);
			window = sd.OutputWindow;
			ID3D11Texture2D* pBackBuffer;
			pSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)& pBackBuffer);
			pDevice->CreateRenderTargetView(pBackBuffer, NULL, &mainRenderTargetView);
			pBackBuffer->Release();
			oWndProc = (WNDPROC)SetWindowLongPtr(window, GWLP_WNDPROC, (LONG_PTR)WndProc);

			InitImGui();
			ImGui::SetNextWindowSize(ImVec2(350, 1050));
			init = true;
		}

		else
			return oPresent(pSwapChain, SyncInterval, Flags);
	}

	if (GetAsyncKeyState(VK_INSERT) & 1)
		bMenuOpen = !bMenuOpen;

	if (GetAsyncKeyState(VK_F9) & 1)
		StartGameFunc();

	if (bMenuOpen)
	{
		ImGuiIO& io = ImGui::GetIO();
		io.WantCaptureMouse = true;
		io.WantCaptureKeyboard = true;

		if (GetAsyncKeyState(VK_LBUTTON))
		{
			io.MouseDown[0] = true;
			io.MouseClicked[0] = true;
		}
		else
		{
			io.MouseReleased[0] = true;
			io.MouseDown[0] = false;
			io.MouseClicked[0] = false;
		}

		/*for (int i : KeyArray)
		{
			if (GetAsyncKeyState(i) & 1)
			{
				io.AddInputCharacter(i);
			}
		}*/





		ImGui_ImplDX11_NewFrame();
		ImGui_ImplWin32_NewFrame();
		ImGui::NewFrame();
		ImGui::Begin("SilverHook", &bMenuOpen);

		ImGui::Text("Language");
		if (ImGui::Checkbox("English", &lEnglish))
		{
			if (lEnglish)
				lRussian = false;
			HasNotChanged = false;
		};
		ImGui::SameLine();
		if (ImGui::Checkbox(u8"Русский", &lRussian))
		{
			if (lRussian)
				lEnglish = false;
			HasNotChanged = false;
		};

		//English
		if (lEnglish && !HasNotChanged) {
			HasNotChanged = true;

			lCheatTitle = u8"Cheats";
			lSteamName = u8"Spoof Steam Name";
			lJoinAsGhost = u8"Join as Ghost";
			lMLH = u8"Multiplayer Lobby Hack";
			lXP = u8"1xp and 99 max lvl";
			lCrasher = u8"Crasher";
			lCrasherText = u8"Only use crasher when\ngame has finished loading.";
			lFunctionCallText = u8"Function Calls";
			lFakeKick = u8"Fake Kick";
			lStartGame = u8"Start Game";
			lDisableDLCs = u8"Disable DLCs";
			lMemAddresses = u8"Mem Addresses";
			lFOW = u8"FOW";
			lAllowTraits = u8"AllowTraits";
			lDBG = u8"Debug";
			lTagSwitchText = u8"Tag Switching";
			lTagSwitch = u8"Tag Switch";
			lReset = u8"Reset";
			lCredits = u8"Credits\nCreator: SilverXK\nTranslator: voiddd";
		}

		//Russian
		if (lRussian && !HasNotChanged) {
			HasNotChanged = true;

			lCheatTitle = u8"Читы";
			lSteamName = u8"Скрыть стим-ник";
			lJoinAsGhost = u8"Невидимка";
			lMLH = u8"Лобби-хак";
			lXP = u8"1xp and 99 max lvl";
			lCrasher = u8"Крашнуть игру (всем)";
			lCrasherText = u8"Используйте 'Crasher'\nтолько после загрузки игры.";
			lFunctionCallText = u8"Вызовы функций";
			lFakeKick = u8"Фейк-самокик";
			lStartGame = u8"Запустить раунд";
			lDisableDLCs = u8"Откл. Длс";
			lMemAddresses = u8"Адреса памяти";
			lFOW = u8"фов";
			lAllowTraits = u8"Ген-Апгрейд";
			lDBG = u8"Отладка";
			lTagSwitchText = u8"Сменить страну";
			lTagSwitch = u8"Сменить";
			lReset = u8"Очистить";
			lCredits = u8"Заслуги\nАвторы: SilverXK\nПеревод: voiddd";
		}

		ImGui::Text(lCheatTitle.c_str());
		ImGui::Checkbox(lSteamName.c_str(), &bMaxNameSize);
		ImGui::Checkbox(lJoinAsGhost.c_str(), &bJoinAsGhost);
		//ImGui::Checkbox("Debug", &Debug);
		ImGui::Checkbox("FakeSpammer", &FakeSpammer);
		ImGui::Checkbox(lMLH.c_str(), &bCE);
		ImGui::Checkbox(lXP.c_str(), &bXP);
		ImGui::Checkbox(lCrasher.c_str(), &bCrasher);
		ImGui::Text(lCrasherText.c_str());
		if (bCrasher) {
			ToggleDLC(0);
		}

		if (bCE) {
			MultiplayerLobbyHack();
		}
		if (bXP) {
			UpgradeLevelLimiter();
		}
		if (FakeSpammer) {
			DWORD* tt = dT;
			__int64 tP = dP;
			CString* tN = dN;
			CString* tNN = dNN;
			CString* empty = new CString;
			CAddPlayerCommand* AddFake = (CAddPlayerCommand*)GetCCommandFunc(200);
			FakeM++;
			tN = (CString*)memcpy(tN, "Silver", sizeof(dN));
			tNN = (CString*)memcpy(tNN, "FUWGbot", sizeof(dNN));
			AddFake = CAddPlayerCommandTramp(AddFake, tN, tNN, tt, FakeM, false, tP);
			CSessionPostTramp(pCSession, AddFake, true);
		}

		ImGui::Text("");
		ImGui::Text(lFunctionCallText.c_str());
		ImGui::Columns(2);
		/*if (ImGui::Button("Fake Leave", ImVec2(140, 28)) && pCSession != nullptr)
		{
			CChatLeaveFake* ChatLeave = (CChatLeaveFake*)GetCCommandFunc(56);

			ChatLeave = ChatLeaveFunc(ChatLeave, 0);
			CSessionPostTramp(pCSession, ChatLeave, true);


		}
		ImGui::NextColumn();*/
		if (ImGui::Button(lStartGame.c_str(), ImVec2(140, 28)) && pCSession != nullptr)
		{

			StartGameFunc();

		}
		ImGui::NextColumn();
		if (ImGui::Button("Reset Fake MachineID", ImVec2(140, 28)) && pCSession != nullptr)
		{

			FakeM = 1;

		}
		ImGui::NextColumn();
		if (ImGui::Button("Add Fake Player", ImVec2(140, 28)) && pCSession != nullptr)
		{
			DWORD* tt = dT;
			__int64 tP = dP;
			CString* tN = dN;
			CString* tNN = dNN;
			CString* empty = new CString;

			CAddPlayerCommand* AddFake = (CAddPlayerCommand*)GetCCommandFunc(200);

			FakeM++;

			if (bFakePname)
			{
				//tN = empty;
				tNN = empty;
				
			}
			tN = (CString*)memcpy(tN, "Silver", sizeof(dN));
			tNN = (CString*)memcpy(tNN, "FUWGbot", sizeof(dNN));
			AddFake = CAddPlayerCommandTramp(AddFake, tN, tNN, tt, FakeM, false, tP);


			CSessionPostTramp(pCSession, AddFake, true);
		}
		ImGui::NextColumn();
		if (ImGui::Button(lDisableDLCs.c_str(), ImVec2(140, 28)) && pCSession != nullptr)
		{
			ToggleDLC(0);
		}
		ImGui::NextColumn();
		if (ImGui::Button("Enable AI on all", ImVec2(140, 28)) && pCSession != nullptr)
		{
			int i = 1;
			do {
				int* TagPtr = &i;
				
				CAiEnableCommand* EnableAI = (CAiEnableCommand*)GetCCommandFunc(56);
				EnableAI = AIEnableFunc(EnableAI, TagPtr, 2);
				CSessionPostTramp(pCSession, EnableAI, 1);
				i++;
			} while (i <= 100);
		}
		ImGui::NextColumn();
		if (ImGui::Button("Become Ghost", ImVec2(140, 28)) && pCSession != nullptr) {
			DWORD* tt = dT; // unknown
			int tM = dM; //machine ID
			__int64 tP = dP; //paradox social ID
			CString* tN = dN; //Steam Name
			CString* tNN = dNN; // HOI4 Name

			CAddPlayerCommand* FakeKick = (CAddPlayerCommand*)GetCCommandFunc(200);
			FakeKick = CAddPlayerCommandTramp(FakeKick, tN, tNN, tt, tM, false, tP);
			CSessionPostTramp(pCSession, FakeKick, true);

			/*CRemovePlayerCommand* RemovePlayer = (CRemovePlayerCommand*)GetCCommandFunc(112);
			RemovePlayer = CRemovePlayerCommandTramp(RemovePlayer, RMID, 3, dUnknown);
			CSessionPostTramp(pCSession, RemovePlayer, true);*/
		}
		ImGui::NextColumn();
		if (ImGui::Button("Infinite Pause", ImVec2(140, 28)) && pCSession != nullptr) {
			CString* empty = new CString;
			CPauseGameCommand* UnpauseGame = (CPauseGameCommand*)GetCCommandFunc(88);
			UnpauseGame = CPauseGameFunc(UnpauseGame, (__int64)empty, 1);
			CSessionPostTramp(pCSession, UnpauseGame, true);
		}
		ImGui::NextColumn();
		if (ImGui::Button("Ghost Pause", ImVec2(140, 28)) && pCSession != nullptr) {
			CString* empty = new CString;
			CPauseGameCommand* UnpauseGame = (CPauseGameCommand*)GetCCommandFunc(88);
			UnpauseGame = CPauseGameFunc(UnpauseGame, (__int64)empty, 0);
			CSessionPostTramp(pCSession, UnpauseGame, true);
		}
		ImGui::Columns(1);
		ImGui::Text("");
		ImGui::Text(lMemAddresses.c_str());
		ImGui::Columns(2);

		if (ImGui::Button(lFOW.c_str(), ImVec2(140, 28)) && pCSession != nullptr)
		{
			ChangeByteAddressValue(0x2AB9DDA);
		}
		ImGui::NextColumn();
		if (ImGui::Button(lAllowTraits.c_str(), ImVec2(140, 28)) && pCSession != nullptr)
		{
			ChangeByteAddressValue(0x2AB9DB8);
		}
		ImGui::NextColumn();
		if (ImGui::Button(lDBG.c_str(), ImVec2(140, 28)) && pCSession != nullptr)
		{
			ChangeByteAddressValue(0x2C96BEC);
		}

		ImGui::Columns(1);
		ImGui::Text("");
		ImGui::Text("Country Tag:");
		ImGui::SetNextItemWidth(70.f);
		ImGui::InputText("", TagBuffer, IM_ARRAYSIZE(TagBuffer));
		ImGui::SameLine();

		if (ImGui::Button("Enable AI") && pCSession != nullptr)
		{
			std::string sTagBuffer = TagBuffer;
			char* endptr;
			int a1 = std::strtol(TagBuffer, &endptr, 10);

			if (sTagBuffer.length() > 0)
			{
				
				//int Tag = std::stoi(sTagBuffer);
				int *TagPtr = &a1;
				//ChangeIntAddressValue(0x2C97110, 0x4B0, Tag);
				CAiEnableCommand* EnableAI = (CAiEnableCommand*)GetCCommandFunc(56);
				EnableAI = AIEnableFunc(EnableAI, TagPtr, 2);
				CSessionPostTramp(pCSession, EnableAI, 1);
			}
		}
		ImGui::SameLine();
		if (ImGui::Button("Disable AI") && pCSession != nullptr)
		{
			std::string sTagBuffer = TagBuffer;
			char* endptr;
			int a1 = std::strtol(TagBuffer, &endptr, 10);
			if (sTagBuffer.length() > 0)
			{
				
				int* TagPtr = &a1;
				//ChangeIntAddressValue(0x2C97110, 0x4B0, Tag);
				CAiEnableCommand* DisableAI = (CAiEnableCommand*)GetCCommandFunc(56);
				DisableAI = AIEnableFunc(DisableAI, TagPtr, 0);
				CSessionPostTramp(pCSession, DisableAI, 1);
			}
		}
		ImGui::SameLine();
		if (ImGui::Button(lReset.c_str()))
		{
			memset(TagBuffer, 0, sizeof(TagBuffer));
		}
		if (ImGui::Button("Tagswitch") && pCSession != nullptr)
		{
			std::string sTagBuffer = TagBuffer;

			if (sTagBuffer.length() > 0)
			{
				int Tag = std::stoi(sTagBuffer);
				ChangeIntAddressValue(0x2C97110, 0x4B0, Tag);
			}
		}
		ImGui::Text("");
		ImGui::Text(lCredits.c_str());
		ImGui::End();
	
		ImGui::Render();

		pContext->OMSetRenderTargets(1, &mainRenderTargetView, NULL);
		ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
	}
	return oPresent(pSwapChain, SyncInterval, Flags);
}

bool __fastcall hkCSessionPost(void* pThis, CCommand* pCommand, bool ForceSend)
{
	//__int64 a1 = (__int64)pCommand;
	pCSession = pThis;


	return CSessionPostTramp(pThis, pCommand, ForceSend);
}

CAddPlayerCommand* __fastcall hkCAddPlayerCommand(void* pThis, CString* User, CString* Name, DWORD* unknown, int nMachineId, bool bHotjoin, __int64 a7)
{
	if (iParadoxSocialID == 0)
		iParadoxSocialID = a7;

	iMachineIDFake = 50;
	iMyMachineID = nMachineId;

	//CString* Ta = new CString("Hi");
	//*Test = "hi";

	

	if (bMaxNameSize)
	{
		
		User = empty;
		

	}
	//printm("AddPlayer1");

	if (bJoinAsGhost)
	{
		User = empty;
		Name = empty;
	}


	//printm("AddPlayer5");
	pCAddPlayer = pThis;
	dN = User;
	dNN = Name;
	dT = unknown;
	dM = nMachineId;
	dP = a7;

	if (!lala) {
		//fM = nMachineId;
		lala = true;
	}

	return CAddPlayerCommandTramp(pThis, User, Name, unknown, nMachineId, bHotjoin, a7);
}

CRemovePlayerCommand* __fastcall hkCRemovePlayerCommand(void* pThis, int _machineID, ERemovalReason eReason, long long a4)
{


	pCRemovePlayer = pThis; RMID = _machineID; dReason = eReason; dUnknown = a4;
	
	
	
	//iMyMachineID = machineID;
	return CRemovePlayerCommandTramp(pThis, _machineID, eReason, a4);
}

__int64 __fastcall hkCGameStateSetPlayer(void* pThis, int* Tag)
{

	pCGameState = pThis;

	return CGameStateSetPlayerTramp(pThis, Tag);
}

CChatMessage* __fastcall hkChatMessage(void* pThis, __int64 a2, __int64 Message) {

	pCMessage = a2;


	return CChatMessageTramp(pThis, a2, Message);
}


CNameChange* __fastcall hkNameChange(void* pThis, CString* name) {

	if (Debug) {
		if (pThis == ((__int64*)((__int64*)pCAddPlayer + 48))) {
			printm((char*)name);
		}
	}

	return CNameChangeTramp(pThis, name);
}

CCreateEquipmentVariant* __fastcall hkCCreateEquipment(void* pThis, __int64 a2, __int64 a3, int a4, __int64* a5, _int64* a6, char a7) {

	if (bXP) {
		a4 = 0;
	}

	return CCreateEquipmentTramp(pThis, a2, a3, a4, a5,a6, a7);
}

void HookFunctions() {

	CSessionPostHook = CSessionPost(GameBase + 0x1DE2AF0);
	MH_CreateHook(CSessionPostHook, &hkCSessionPost, (LPVOID*)&CSessionPostTramp);
	MH_EnableHook(CSessionPostHook);

	CAddPlayerCommandHook = GetCAddPlayerCommand(GameBase + 0x1650E80);

	MH_CreateHook(CAddPlayerCommandHook, &hkCAddPlayerCommand, (LPVOID*)&CAddPlayerCommandTramp);
	MH_EnableHook(CAddPlayerCommandHook);

	CGameStateSetPlayerHook = CGameStateSetPlayer(GameBase + 0x1BCCA0); //0xB8D50 1.7.1 //0x142090 modern 

	MH_CreateHook(CGameStateSetPlayerHook, &hkCGameStateSetPlayer, (LPVOID*)&CGameStateSetPlayerTramp);
	MH_EnableHook(CGameStateSetPlayerHook);

	CRemovePlayerCommandHook = GetCRemovePlayerCommand(GameBase + 0x1650F60);

	MH_CreateHook(CRemovePlayerCommandHook, &hkCRemovePlayerCommand, (LPVOID*)&CRemovePlayerCommandTramp);
	MH_EnableHook(CRemovePlayerCommandHook);

	CChatMessageHook = GetCChatMessage(GameBase + 0x1E939A0);
	MH_CreateHook(CChatMessageHook, &hkChatMessage, (LPVOID*)&CChatMessageTramp);
	MH_EnableHook(CChatMessageHook);

	CCreateEquipmentFunc = GetCCreateEquipmentVariant(GameBase + 0x170C430);
	MH_CreateHook(CCreateEquipmentFunc, &hkCCreateEquipment, (LPVOID*)&CCreateEquipmentTramp);
	MH_EnableHook(CCreateEquipmentFunc);


	//CNameChangeFunc = GetCNameChangeCommand(GameBase + 0x104F70);
	CSetDLCsCommandFunc = GetCSetDLCsCommand(GameBase + 0x1650FF0);

	CStartGameCommandFunc = GetCStartGameCommand(GameBase + 0x12724F0);
	GetCCommandFunc = GetCCommand(GameBase + 0x2112854);
	CNameChangeFunc = GetCNameChangeCommand(GameBase + 0x170C430);
	AIEnableFunc = GetEnableAI(GameBase + 0xBD4EB0);
	ChatLeaveFunc = GetCChatLeaveFake(GameBase + 0x109AED0);
	CPauseGameFunc = GetCPauseGameCommand(GameBase + 0xC2EEC0);

	MH_CreateHook(CNameChangeFunc, &hkNameChange, (LPVOID*)&CNameChangeTramp);
	MH_EnableHook(CNameChangeFunc);
}

DWORD WINAPI MainThread(LPVOID lpReserved)
{
	bool init_hook = false;
	do
	{
		if (kiero::init(kiero::RenderType::D3D11) == kiero::Status::Success)
		{
			kiero::bind(8, (void**)& oPresent, hkPresent);
			init_hook = true;
		}
	} while (!init_hook);

	HookFunctions();
	return TRUE;
}

BOOL WINAPI DllMain(HMODULE hMod, DWORD dwReason, LPVOID lpReserved)
{
	switch (dwReason)
	{
	case DLL_PROCESS_ATTACH:
		DisableThreadLibraryCalls(hMod);
		CreateThread(nullptr, 0, MainThread, hMod, 0, nullptr);
		//AllocConsole();
		//printm("Loaded");
		break;
	case DLL_PROCESS_DETACH:
		kiero::shutdown();
		break;
	}
	return TRUE;
}